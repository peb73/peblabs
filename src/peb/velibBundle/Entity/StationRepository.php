<?php

namespace peb\velibBundle\Entity;

use Doctrine\Common\Collections\ArrayCollection;
use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\Query\ResultSetMapping;
use Symfony\Component\Validator\Constraints\DateTime;

/**
 * StationRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class StationRepository extends EntityRepository
{

    /**
     * @param int $number Number
     * @return array
     */
    public function getStats($number){
        $date = new \DateTime();
        $date->modify('-90 days');

        $em = $this->getEntityManager();

        $rsm = new ResultSetMapping();

        $rsm->addScalarResult('minute', 'minute');
        $rsm->addScalarResult('hour', 'hour');
        $rsm->addScalarResult('average', 'average');

        $query = $em->createNativeQuery(
            'SELECT avg(i.available_bikes) as average, '.
            'date_format(i.date,"%i") as minute, '.
            'date_format(i.date,"%H") as hour '.
            'from Info i '.
            'WHERE i.station_number=:number '.
            'and i.date > :date '.
            'group by date_format(i.date,"%H%i")',$rsm
        )->setParameter('number',$number)
            ->setParameter('date', $date);

        $infos = $query->getResult();

        $beforeAverage = array();
         for($i=0;$i<1440;$i=$i+5){
             $beforeAverage[$i]=array();

             for($j=0;$j<sizeof($infos);$j++){
                 if($infos[$j]==null){
                     continue;
                 }

                 $info = $infos[$j];
                 $tmp = $info['hour']*60+$info['minute']*1;

                 if($tmp>=$i&&$tmp<$i+5){
                    $beforeAverage[$i][] = $info['average'];
                    $infos[$j]=null;
                 }


             }
         }

        $result = array();
        for($i=0;$i<1440;$i=$i+5){
            $average = 0;
            if(sizeof($beforeAverage[$i])>0){
                for($j=0; $j<sizeof($beforeAverage[$i]);$j++){
                    $value = $beforeAverage[$i][$j];
                    $average += $value;
                }

                $average = $average/sizeof($beforeAverage[$i]);
                //unset($beforeAverage[$i]);
            }
            $result[$i] = $average;
        }

        return $result;
    }
}
